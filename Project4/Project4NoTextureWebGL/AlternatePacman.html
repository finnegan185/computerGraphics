<!DOCTYPE html>
<meta charset="UTF-8">
<html>
<!--
	Project 4 for CMSC 405 Computer Graphics
	
	Title Pac-Man Defense. A Pac-Man ghost in it's vulnerable state
	drags a massive spiked ball behind it with a chain and belt.
	
	There are four different lighting options.
   
	Derived from diskplay.html which was derived from Diskworld-2.html 
	I added some of the Diskworld-2.html code back in that was removed
	for diskplay to add in the functionality that I wanted. Specifically
	regarding spotlights.
      
-->
<head>
<title>Pac-Man Defense</title>
<style>
    body {
        background-color: #EEEEEE;
    }
    label {
        white-space: pre;
        margin-left: 25px;
    }
</style>

<!-- This shader is exactly as provided -->

<script type="x-shader/x-vertex" id="vshader-source">
    attribute vec3 a_coords;
    attribute vec3 a_normal;   
    uniform mat4 modelview;
    uniform mat4 projection;   
    varying vec3 v_normal;
    varying vec3 v_eyeCoords;
  
    void main() {
        vec4 coords = vec4(a_coords,1.0);
        vec4 eyeCoords = modelview * coords;
        gl_Position = projection * eyeCoords;
        v_normal = normalize(a_normal);
        v_eyeCoords = eyeCoords.xyz/eyeCoords.w;         
    }
</script>

<!-- I took the shader from diskplay and added some of the functionality back
	that was removed from diskworld-2. Specifically I wanted spotlights.-->
<script type="x-shader/x-fragment" id="fshader-source">
 #ifdef GL_FRAGMENT_PRECISION_HIGH
       precision highp float;
    #else
       precision mediump float;
    #endif
    struct MaterialProperties {
        vec4 diffuseColor;      // diffuseColor.a is alpha for the fragment
        vec3 specularColor;
        vec3 emissiveColor;
        float specularExponent;
    };
    struct LightProperties {
        bool enabled;
        vec4 position;
        vec3 color;
        vec3 spotDirection;  // Note: only a point light can be a spotlight
        float spotCosineCutoff; // if <= 0, this is not a spotlight, if >= 1, the light cone shrinks to nothing
        float spotExponent;
    };
    uniform MaterialProperties material; // do two-sided lighting, but assume front and back materials are the same
    uniform LightProperties lights[5];
    uniform mat3 normalMatrix;
    varying vec3 v_normal;
    varying vec3 v_eyeCoords;
    vec3 lightingEquation( LightProperties light, MaterialProperties material, 
                                vec3 eyeCoords, vec3 N, vec3 V ) {
           // N is normal vector, V is direction to viewer.
        vec3 L, R; // Light direction and reflected light direction.
        float spotFactor = 1.0;  // multiplier to account for spotlight
        if ( light.position.w == 0.0 ) {
            L = normalize( light.position.xyz );
        }
        else {
            L = normalize( light.position.xyz/light.position.w - v_eyeCoords );
            if (light.spotCosineCutoff > 0.0) { // the light is a spotlight
                vec3 D = -normalize(light.spotDirection);
                float spotCosine = dot(D,L);
                if (spotCosine >= light.spotCosineCutoff) { 
                    spotFactor = pow(spotCosine,light.spotExponent);
                }
                else { // The point is outside the cone of light from the spotlight.
                    spotFactor = 0.0; // The light will add no color to the point.
                }
            }
        }
        if (dot(L,N) <= 0.0) {
            return vec3(0.0);
        }
        vec3 reflection = dot(L,N) * light.color * material.diffuseColor.rgb;
        R = -reflect(L,N);
        if (dot(R,V) > 0.0) {
            float factor = pow(dot(R,V),material.specularExponent);
            reflection += factor * material.specularColor * light.color;
        }
        return spotFactor*reflection;
    }
    void main() {
        vec3 normal = normalize( normalMatrix*v_normal );
        vec3 viewDirection = normalize( -v_eyeCoords);  // (Assumes a perspective projection.)
        vec3 color = material.emissiveColor;
        for (int i = 0; i < 5; i++) {
            if (lights[i].enabled) { 
                if (gl_FrontFacing) {
                    color += lightingEquation( lights[i], material, v_eyeCoords,
                                                    normal, viewDirection);
                }
                else {
                    color += lightingEquation( lights[i], material, v_eyeCoords,
                                                    -normal, viewDirection);
                }
            }
        }
        gl_FragColor = vec4(color,material.diffuseColor.a);
    }
</script>


<script src="gl-matrix-min.js"></script>
<script src="trackball-rotator.js"></script>
<script src="basic-object-models-IFS.js"></script>
<script>

"use strict";

//Kept most of these global variables the same. Added a couple extra for myself.

var gl;   // The webgl context.


var xval = -15;
var yval = 0;

var a_coords_loc;         // Location of the a_coords attribute variable in the shader program.
var a_normal_loc;         // Location of a_normal attribute 
var a_texCoords_loc; 
// var texture;

var u_modelview;       // Locations for uniform matrices
var u_projection;
var u_normalMatrix;

var u_material;     // An object tolds uniform locations for the material.
var u_lights;       // An array of objects that holds uniform locations for light properties.

var projection = mat4.create();    // projection matrix
var modelview;                     // modelview matrix; value comes from rotator
var normalMatrix = mat3.create();  // matrix, derived from modelview matrix, for transforming normal vectors

var rotator;  // A TrackballRotator to implement rotation by mouse.

var frameNumber = 0;  // frame number during animation (actually only goes up by 0.5 per frame)

var torus, sphere, ghostSphere, cone, ghostCone, ghostCylinder, disk, ring, eyebrow, cube;  // basic objects, created using function createModel

var sphereVertexCoords;

var matrixStack = [];           // A stack of matrices for implementing hierarchical graphics.

var currentColor = [1,1,1,1];   // The current diffuseColor; render() functions in the basic objects set
                                // the diffuse color to currentColor when it is called before drawing the object.
                                // Other color properties, which don't change often are handled elsewhere.

//These three values are used to control the colors of the lights.
var rCol = 1; 
var gCol = 0;
var bCol = 0;



/**
 * Draws the image, which consists of a spikeball, ghost or beefy ghost, floor and chains.
 */
function draw() {
    gl.clearColor(0,0,0,1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    
    
    mat4.perspective(projection, Math.PI/4, 1, 1, 50);
    gl.uniformMatrix4fv(u_projection, false, projection );

    modelview = rotator.getViewMatrix();
    
    spotLights();
	
	gl.uniform3f( u_material.emissiveColor, 0.2, 0.2, 0.2 );
	floor();
	gl.uniform3f( u_material.emissiveColor, 0, 0, 0 );
		
    mat4.translate(modelview, modelview, [xval, 0, 0]);

	pushMatrix();
	mat4.rotateX(modelview,modelview,(45)/180*Math.PI);
    spikeBall();
	popMatrix();
	pushMatrix();
	mat4.rotateX(modelview,modelview,(-45)/180*Math.PI);
	if(isBeefy){
		beefyGhost();
	} else {
		ghost();
	}
	popMatrix();
	pushMatrix();
	mat4.rotateX(modelview,modelview,(-45)/180*Math.PI);
	chain();
	popMatrix();

}

//Took the below code from diskworld-2 and added it to diskplay to get additional
//light functionality.
function setSpotlightDirection( u_direction_loc, modelview, lightDirection ) {
    mat3.normalFromMat4(normalMatrix,modelview);
    var transformedDirection = new Float32Array(3);
    vec3.transformMat3(transformedDirection, lightDirection, normalMatrix);
    gl.uniform3fv(u_direction_loc, transformedDirection);
}

function setLightPosition( u_position_loc, modelview, lightPosition ) {
    var transformedPosition = new Float32Array(4);
    vec4.transformMat4(transformedPosition, lightPosition, modelview);
    gl.uniform4fv(u_position_loc, transformedPosition);
}

//Function for activating and setting up the spotlights.
function spotLights() {    

    pushMatrix();
	setLightPosition(u_lights[3].position, modelview, [-10,15,0,1]);
	setSpotlightDirection(u_lights[3].spotDirection, modelview, [0,-1,0]);
    gl.uniform3f( u_lights[3].color, 1,1,1); 
	gl.uniform1f( u_lights[3].spotCosineCutoff, Math.cos(15/180 * Math.PI) );
    gl.uniform1f( u_lights[3].spotExponent, 5);
	popMatrix();
	
	pushMatrix();
	setLightPosition(u_lights[4].position, modelview, [0,0,15,1]);
	setSpotlightDirection(u_lights[4].spotDirection, modelview, [0,0,-1]);
    gl.uniform3f( u_lights[4].color, 1,1,1); 
	gl.uniform1f( u_lights[4].spotCosineCutoff, Math.cos(15/180 * Math.PI) );
    gl.uniform1f( u_lights[4].spotExponent, 5);
	popMatrix();
    
    currentColor = [ 1, 1, 1, 0.7 ];
  
   
}

/**
 * The functions below create the objects in the scene. This includes the '
 * spikeball, chain, ghost and floor. Beefy Ghost is near the bottom below
 * the light controls section.
 */
function spikeBall() {	
	//schere/ball thing
	pushMatrix();
	gl.uniform3f( u_material.specularColor, 0.6, 0.6, 0.6 );
	currentColor = [0.3,0.3,0.3,1];
	sphere.render();
	popMatrix();
	
	//Spikes
	var count = 0;


	var rColor = 0.7;
	
	var anglesBackInner = [180, 0 ,0, 200, 15, 0, 210, 0, 0, 200, -15, 0, 180, -30, 0, 160, -15, 0, 150, 0, 0, 160, 15, 0, 180, 30,0];
	var anglesBackOuter = [230, 35, 0, 240, 0, 0, 230, -35, 0, 180, -55, 0, 130, -35, 0, 120, 0, 0, 130, 35, 0, 180, 55,0];
	var anglesMiddle = [180, 90,0, 270, 45, 0, 270, 0, 0, 270, -45, 0, 180, -90, 0, 90, -45, 0, 90, 0, 0, 90, 45, 0];
	var anglesFrontOuter = [180, 120, 0, 305, 40, 0, 300, 0, 0, 305, -40, 0, 180, -120, 0, 45, -35, 0, 60, 0, 0, 50, 38, 0];
	var anglesFrontInner = [180, 150, 0, 340, 15, 0, 330, 0, 0, 340, -15, 0, 180, -150, 0, 20, -20, 0, 25, 0, 0, 20, 20, 0, 0, 0, 0];

	for (var i = 0; i < sphereVertexCoords.length; i += 3){
		pushMatrix();
		if(i <= 52){
			mat4.translate(modelview, modelview, [sphereVertexCoords[i],sphereVertexCoords[i+1],sphereVertexCoords[i+2]]);
			mat4.rotateX(modelview,modelview,(anglesBackInner[count])/180*Math.PI);
			mat4.rotateY(modelview,modelview,(anglesBackInner[count+1])/180*Math.PI);
			currentColor = [rColor, 0.7, 0.7, 1];
			cone.render();
			popMatrix();
		} else if ( i == 54 ){
			count = 0;
			continue;
		} else if ( i > 55 && i <= 78) {
			mat4.translate(modelview, modelview, [sphereVertexCoords[i],sphereVertexCoords[i+1],sphereVertexCoords[i+2]]);
			mat4.rotateX(modelview,modelview,(anglesBackOuter[count])/180*Math.PI);
			mat4.rotateY(modelview,modelview,(anglesBackOuter[count+1])/180*Math.PI);
			currentColor = [rColor, 0.7, 0.7, 1];
			cone.render();
			popMatrix();
		} else if (i > 78 && i <= 105){
			if(i == 81){ count = 0;}
			mat4.translate(modelview, modelview, [sphereVertexCoords[i],sphereVertexCoords[i+1],sphereVertexCoords[i+2]]);
			mat4.rotateX(modelview,modelview,(anglesMiddle[count])/180*Math.PI);
			mat4.rotateY(modelview,modelview,(anglesMiddle[count+1])/180*Math.PI);
			currentColor = [rColor, 0.7, 0.7, 1];
			cone.render();
			popMatrix();
		} else if (i > 105 && i <= 129){
			if(i == 108){ 
				count = 0;
			}
			mat4.translate(modelview, modelview, [sphereVertexCoords[i],sphereVertexCoords[i+1],sphereVertexCoords[i+2]]);
			mat4.rotateX(modelview,modelview,(anglesFrontOuter[count])/180*Math.PI);
			mat4.rotateY(modelview,modelview,(anglesFrontOuter[count+1])/180*Math.PI);
			currentColor = [rColor, 0.7, 0.7, 1];
			cone.render();
			popMatrix();
		} else if(i == 132) {
			count = 0;
			continue;
		} else if (i > 134 && i <= 162){
			if(i == 108){ 
				count = 0;
			} else if(i == 159){continue;}
			mat4.translate(modelview, modelview, [sphereVertexCoords[i],sphereVertexCoords[i+1],sphereVertexCoords[i+2]]);
			mat4.rotateX(modelview,modelview,(anglesFrontInner[count])/180*Math.PI);
			mat4.rotateY(modelview,modelview,(anglesFrontInner[count+1])/180*Math.PI);
			currentColor = [rColor, 0.7, 0.7, 1];
			cone.render();
			popMatrix();
		}
		count += 3;
		if(i == 0){
			i = 27;
		}

	}

	popMatrix();

}

function ghost(){
	//head
	pushMatrix();
	mat4.translate(modelview, modelview, [0, 0 + yval, 0]);

	pushMatrix();
	gl.uniform3f( u_material.specularColor, 0.2, 0.2, 0.2 );
	gl.uniform3f( u_material.emissiveColor, 0, 0, 0.2 );
	mat4.translate(modelview, modelview, [9,1,0]);
	currentColor = [0.5,0.5,1,0.3];
	ghostSphere.render();
	popMatrix();
	
	//torso
	pushMatrix();
	mat4.translate(modelview, modelview, [9,0.25,0]);
	mat4.rotateX(modelview,modelview,(90)/180*Math.PI);
	ghostCylinder.render();
	popMatrix();
	
	var positions = [9, 0, 9.66, 0, 8.33, 0, 9.33, .6, 8.66, .6, 9.33, -.6, 8.66, -.6]
	
	//Bottome spikes
	for(var i = 0; i < 15; i+=2){
	
		pushMatrix();
		mat4.translate(modelview, modelview, [positions[i],-.9,positions[i+1]]);
		mat4.rotateX(modelview,modelview,(90)/180*Math.PI);
		ghostCone.render();
		popMatrix();
	}
	
	//Eyes
	var zEyePos = [0.33, -0.33];
	for(var i = 0; i <= 1; i++){
		pushMatrix();
		gl.uniform3f( u_material.emissiveColor, 0.6, 0.7, 0.8 );
		mat4.translate(modelview, modelview, [9.85, 0.9, zEyePos[i]]);
		mat4.scale(modelview,modelview,[0.3,0.3,0.3]);
		currentColor = [1,1,1,0.8];
		cube.render();
		popMatrix();
	}
	
	//Mustache THIS WAS AN ACCIDENT AND I LOVE IT
	var mPos = [10, .1, 10, -.1];
	for(var i = 0; i <= 3; i += 2){
		pushMatrix();
		mat4.translate(modelview, modelview, [mPos[i], 0.2, mPos[i+1]]);
		mat4.scale(modelview,modelview,[0.1,0.1,0.4]);
		mat4.rotateX(modelview, modelview, (45)/180*Math.PI)
		currentColor = [1,1,1,0.8];
		cube.render();
		popMatrix();
	}
	
	//mouth
	var mouthPos = [10,    .1,
					10,   -.1,
					9.97,  .3,
					9.97, -.3,
					9.9,   .5,
					9.9,  -.5];
	var mRota = [55,  0, 
				-55,  0,
				-55, -10,
				 55,  10,
				 55, -10,
				-55,  10];
	for(var i = 0; i <= 13; i += 2){
		pushMatrix();
		mat4.translate(modelview, modelview, [mouthPos[i], -.075, mouthPos[i+1]]);
		mat4.rotateX(modelview, modelview, (mRota[i])/180*Math.PI);
		mat4.rotateY(modelview, modelview, (mRota[i+1])/180*Math.PI);
		mat4.scale(modelview,modelview,[0.075,0.075,0.4]);
		currentColor = [1,1,1,0.8];
		cube.render();
		popMatrix();
	}
	
	// This section creates the belt and changes the emissive color because the belt isn't ethereal.
	pushMatrix();
	gl.uniform3f( u_material.emissiveColor, 0, 0, 0 );

	mat4.translate(modelview, modelview, [9, 0.5, 0]);
	mat4.scale(modelview,modelview,[1,4,1]);
	mat4.rotateX(modelview, modelview, (90)/180*Math.PI)
	currentColor = [0.396,0.263,0.129, 1];
	ring.render();
	popMatrix();
	gl.uniform3f( u_material.emissiveColor, 0, 0, 0 );
	mat4.translate(modelview, modelview, [0, 0, 0]);

	popMatrix();
}

function chain(){

	var linkVals = [2.9, 0.75,  0, 90,
					3.6, 0.75,  0, 0,
					4.3, 0.7,   0, 90,
					4.9, 0.66,  0, 0,
					5.5, 0.62,  0, 90, 
					6.1, 0.58,  0, 0,
					6.7, 0.54,  0, 90,
					7.4, 0.52,  0, 0,
					8.0, 0.50,  0, 90];
					
	var count = 0;
	var movePercent = 0;
	for(var i = 0; i <= 32; i += 4){
		pushMatrix();
		gl.uniform3f( u_material.specularColor, 0.6, 0.6, 0.6 );
		mat4.translate(modelview, modelview, [linkVals[i], linkVals[i+1] + (yval*movePercent), linkVals[i+2]]);
		mat4.rotateX(modelview, modelview, (linkVals[i+3])/180*Math.PI);
		mat4.scale(modelview, modelview, [0.8, 0.8, 0.8]);
		currentColor = [0.768,0.612,0.282,1];
		torus.render();
		popMatrix();
		count++;
		movePercent = count / 9;
	}
	gl.uniform3f( u_material.specularColor, 0.2, 0.2, 0.2 );

	gl.uniform3f( u_material.emissiveColor, 0, 0, 0 );

	popMatrix();

}

function floor(){
		pushMatrix();
		mat4.translate(modelview, modelview, [-5,-3.5,-3]);
		mat4.rotateX(modelview,modelview,(90)/180*Math.PI);
		currentColor = [0.5,0.5,0.5,1];
		disk.render();
		popMatrix();
}



//Taken and not modified from diskplay
/**
 *  Push a copy of the current modelview matrix onto the matrix stack.
 */
function pushMatrix() {
    matrixStack.push( mat4.clone(modelview) );
}


/**
 *  Restore the modelview matrix to a value popped from the matrix stack.
 */
function popMatrix() {
    modelview = matrixStack.pop();
}

//Taken and not modified from diskplay
/**
 *  Create one of the basic objects.  The modelData holds the data for
 *  an IFS using the structure from basic-objects-IFS.js.  This function
 *  creates VBOs to hold the coordinates, normal vectors, and indices
 *  from the IFS, and it loads the data into those buffers.  The function
 *  creates a new object whose properties are the identifies of the
 *  VBOs.  The new object also has a function, render(), that can be called to
 *  render the object, using all the data from the buffers.  That object
 *  is returned as the value of the function.  (The second parameter,
 *  xtraTranslate, is there because this program was ported from a Java
 *  version where cylinders were created in a different position, with
 *  the base on the xy-plane instead of with their center at the origin.
 *  The xtraTranslate parameter is a 3-vector that is applied as a
 *  translation to the rendered object.  It is used to move the cylinders
 *  into the position expected by the code that was ported from Java.)
 */
function createModel(modelData, xtraTranslate) {
    var model = {};
    model.coordsBuffer = gl.createBuffer();
    model.normalBuffer = gl.createBuffer();
    model.indexBuffer = gl.createBuffer();
    model.count = modelData.indices.length;
    if (xtraTranslate)
        model.xtraTranslate = xtraTranslate;
    else
        model.xtraTranslate = null;
    gl.bindBuffer(gl.ARRAY_BUFFER, model.coordsBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexPositions, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ARRAY_BUFFER, model.normalBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, modelData.vertexNormals, gl.STATIC_DRAW);
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, model.indexBuffer);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, modelData.indices, gl.STATIC_DRAW);
    model.render = function() {  // This function will render the object.
           // Since the buffer from which we are taking the coordinates and normals
           // change each time an object is drawn, we have to use gl.vertexAttribPointer
           // to specify the location of the data. And to do that, we must first
           // bind the buffer that contains the data.  Similarly, we have to
           // bind this object's index buffer before calling gl.drawElements.
        gl.bindBuffer(gl.ARRAY_BUFFER, this.coordsBuffer);
        gl.vertexAttribPointer(a_coords_loc, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ARRAY_BUFFER, this.normalBuffer);
        gl.vertexAttribPointer(a_normal_loc, 3, gl.FLOAT, false, 0, 0);
        gl.uniform4fv(u_material.diffuseColor, currentColor);
        if (this.xtraTranslate) {
            pushMatrix();
            mat4.translate(modelview,modelview,this.xtraTranslate);
        }
        gl.uniformMatrix4fv(u_modelview, false, modelview );
        mat3.normalFromMat4(normalMatrix, modelview);
        gl.uniformMatrix3fv(u_normalMatrix, false, normalMatrix);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.drawElements(gl.TRIANGLES, this.count, gl.UNSIGNED_SHORT, 0);
        if (this.xtraTranslate) {
            popMatrix();
        }
    }
    return model;
}

//Didn't touch this from diskplay
/* Creates a program for use in the WebGL context gl, and returns the
 * identifier for that program.  If an error occurs while compiling or
 * linking the program, an exception of type String is thrown.  The error
 * string contains the compilation or linking error.  If no error occurs,
 * the program identifier is the return value of the function.
 *    The second and third parameters are the id attributes for <script>
 * elementst that contain the source code for the vertex and fragment
 * shaders.
 */
function createProgram(gl, vertexShaderID, fragmentShaderID) {
    function getTextContent( elementID ) {
            // This nested function retrieves the text content of an
            // element on the web page.  It is used here to get the shader
            // source code from the script elements that contain it.
        var element = document.getElementById(elementID);
        var node = element.firstChild;
        var str = "";
        while (node) {
            if (node.nodeType == 3) // this is a text node
                str += node.textContent;
            node = node.nextSibling;
        }
        return str;
    }
    try {
        var vertexShaderSource = getTextContent( vertexShaderID );
        var fragmentShaderSource = getTextContent( fragmentShaderID );
    }
    catch (e) {
        throw "Error: Could not get shader source code from script elements.";
    }
    var vsh = gl.createShader( gl.VERTEX_SHADER );
    gl.shaderSource(vsh,vertexShaderSource);
    gl.compileShader(vsh);
    if ( ! gl.getShaderParameter(vsh, gl.COMPILE_STATUS) ) {
        throw "Error in vertex shader:  " + gl.getShaderInfoLog(vsh);
     }
    var fsh = gl.createShader( gl.FRAGMENT_SHADER );
    gl.shaderSource(fsh, fragmentShaderSource);
    gl.compileShader(fsh);
    if ( ! gl.getShaderParameter(fsh, gl.COMPILE_STATUS) ) {
       throw "Error in fragment shader:  " + gl.getShaderInfoLog(fsh);
    }
    var prog = gl.createProgram();
    gl.attachShader(prog,vsh);
    gl.attachShader(prog, fsh);
    gl.linkProgram(prog);
    if ( ! gl.getProgramParameter( prog, gl.LINK_STATUS) ) {
       throw "Link error in program:  " + gl.getProgramInfoLog(prog);
    }
    return prog;
}

//I readded some of the functionality of diskworld-2.html to diskplay to create 
//the function below. Wanted more lighting options
/* Initialize the WebGL context.  Called from init() */
function initGL() {
    var prog = createProgram(gl,"vshader-source","fshader-source");
    gl.useProgram(prog);
    gl.enable(gl.DEPTH_TEST);
    
    /* Get attribute and uniform locations */
    
    a_coords_loc =  gl.getAttribLocation(prog, "a_coords");
    a_normal_loc =  gl.getAttribLocation(prog, "a_normal");
    gl.enableVertexAttribArray(a_coords_loc);
    gl.enableVertexAttribArray(a_normal_loc);
    
    u_modelview = gl.getUniformLocation(prog, "modelview");
    u_projection = gl.getUniformLocation(prog, "projection");
    u_normalMatrix =  gl.getUniformLocation(prog, "normalMatrix");
    u_material = {
        diffuseColor: gl.getUniformLocation(prog, "material.diffuseColor"),
        specularColor: gl.getUniformLocation(prog, "material.specularColor"),
        emissiveColor: gl.getUniformLocation(prog, "material.emissiveColor"),
        specularExponent: gl.getUniformLocation(prog, "material.specularExponent")
    };
    u_lights = new Array(5);
    for (var i = 0; i < 5; i++) {
        u_lights[i] = {
            enabled: gl.getUniformLocation(prog, "lights[" + i + "].enabled"),
            position: gl.getUniformLocation(prog, "lights[" + i + "].position"),
            color: gl.getUniformLocation(prog, "lights[" + i + "].color"),
            spotDirection: gl.getUniformLocation(prog, "lights[" + i + "].spotDirection"),
            spotCosineCutoff: gl.getUniformLocation(prog, "lights[" + i + "].spotCosineCutoff"),
            spotExponent: gl.getUniformLocation(prog, "lights[" + i + "].spotExponent"),
        };
    }
            
    gl.uniform3f( u_material.specularColor, 0.1, 0.1, 0.1 );  // specular properties don't change
    gl.uniform1f( u_material.specularExponent, 16 );
    gl.uniform3f( u_material.emissiveColor, 0, 0, 0);  // default, will be changed temporarily for some objects
    

    for (var i = 0; i < 5; i++) { // set defaults for lights
         gl.uniform1i( u_lights[i].enabled, 0 ); 
        gl.uniform4f( u_lights[i].position, 0, 0, 1, 1 );
        gl.uniform1f( u_lights[i].spotCosineCutoff, 0); // not a spotlight
        gl.uniform3f( u_lights[i].spotDirection, 0,0,-1);
        gl.uniform1f( u_lights[i].spotExponent, 5);
        gl.uniform3f( u_lights[i].color, 1,1,1 );
    }
	


  // Lights are set on in the draw() method
    
  
    
} // end initGL()



//--------------------------------- animation framework ------------------------------

    
var animating = false;

/*
Animation section. Most of it was taken from diskplay.js and was modified to suit my 
needs. The animated things are the ghost, belt, chain and ball. The chain is my favorite bit.
*/
var beefyMult = 1;
var yInc = 0.02 * beefyMult;
var xInc = 0.05;

function frame() {
    if (animating) {
        frameNumber += 1;
        // Positions of the soccer ball       
        xval += xInc;
		yval += yInc;

        if (xval > 11) {
           xval= -38;
        } 
		
		if (yval > 0.5){
			yInc = -0.02 * beefyMult;
		} else if (yval < -0.25){
			yInc = 0.02 * beefyMult;
		}

        draw();
        requestAnimationFrame(frame);
    }
}

function setAnimating(run) {
    if (run != animating) {
        animating = run;
        if (animating)
            requestAnimationFrame(frame);
    }
}

//--------------------------------- Light Control -----------------------------------
/*
 * This section controls the lights based on user input. There are two directional
 * lights, one ambient ish light and 2 spotlights. The directional and ambient 
 * lights can have their color changed by sliders.
 */
 
 function resetLightsAndBeefy(){
	hLightUpdate(false);
	sideLightUpdate(false);
	amLightUpdate(false);
	spLightUpdate(false);
	rCol = 1;
	gCol = 0;
	bCol = 0;
	updateAllLightsColor();
	beefy(false);
 }
 //This section turns on and off the head on light.
var hLight = false;

function hLightUpdate(isOn){
 	if(isOn != hLight){
		hLight = isOn; 
		if(isOn){
			gl.uniform1i( u_lights[1].enabled, 1 ); 
			gl.uniform4f( u_lights[1].position, 1,0,0,0 ); 
			gl.uniform3f( u_lights[1].color, 1.0,1.0,1.0); 
		} else {
			gl.uniform1i( u_lights[1].enabled, 0 );
		} 
	}	
	draw();
}

//This section turns on and off the colored Lights.
var sideLight = false;

function sideLightUpdate(isOn){
 	if(isOn != sideLight){
		 sideLight = isOn; 
		if(isOn){
			gl.uniform1i( u_lights[0].enabled, 1 );   
			gl.uniform4f( u_lights[0].position, -2,0,0,0 ); 
			gl.uniform3f( u_lights[0].color, rCol, gCol, bCol);  
		} else {
			gl.uniform1i( u_lights[0].enabled, 0 );
		} 
	}	
	draw();
}

//This section turns on and off the ambient light.
var amLight = false;

function amLightUpdate(isOn){
 	if(isOn != amLight){
		amLight = isOn; 
		if(isOn){
			gl.uniform1i( u_lights[2].enabled, 1 );   
			gl.uniform4f( u_lights[2].position, 0,4,4,0); 
			gl.uniform3f( u_lights[2].color, 0.5, 0.5, 0.5);  
		} else {
			gl.uniform1i( u_lights[2].enabled, 0 );
		} 
	}	
	draw();
}

//This section controls the spot lights activations.
var spLight = false;

function spLightUpdate(isOn){
 	if(isOn != spLight){
		spLight = isOn; 
		if(isOn){
			gl.uniform1i( u_lights[3].enabled, 1 );   
			gl.uniform1i( u_lights[4].enabled, 1 );   
		} else {
			gl.uniform1i( u_lights[3].enabled, 0 );   
			gl.uniform1i( u_lights[4].enabled, 0 ); 		
		} 
	}	
	draw();
}

//The next three functions update the color values based on user input.
function updateRed(value){
 	if(value != rCol){
		rCol = value; 
		updateAllLightsColor();

	}	
}

function updateGreen(value){
 	if(value != gCol){
		gCol = value; 
		updateAllLightsColor();
	}	
}

function updateBlue(value){
 	if(value != bCol){
		bCol = value; 
		updateAllLightsColor();

	}	
}

//Updates the colors for all lights that are not spotlights.
function updateAllLightsColor(){
	gl.uniform3f( u_lights[0].color, rCol, gCol, bCol); 
	gl.uniform3f( u_lights[1].color, rCol, gCol, bCol); 
	gl.uniform3f( u_lights[2].color, rCol, gCol, bCol); 
	
	draw();
}

//----------------------- Beefy -------------------------------
// Activates and Deactivates Beefy Ghost based on user input.

var isBeefy = false;

function beefy(isOn){
	console.log("lLightUpdate Happened");
	if(isOn != isBeefy){
		isBeefy = isOn; 
		if(isBeefy){
			xInc = .1;
			beefyMult = 1.2
		} else {
			xInc = 0.05;
			beefyMult = 1;
		}
	}
	draw();

}

function beefyGhost()	{
	/* Basically creates an over powered ghost. Emissive and skin color have a red hue.
	 * I did this to emphasize beefy ghost is jacked and working hard.
	 */
	 
	//head
	pushMatrix();
	mat4.translate(modelview, modelview, [0, 0 + yval, 0]);

	pushMatrix();
	gl.uniform3f( u_material.specularColor, 0.2, 0.2, 0.2 );
	gl.uniform3f( u_material.emissiveColor, 0.3, 0, 0.2 );
	mat4.translate(modelview, modelview, [9,1,0]);
	currentColor = [0.5,0.5,1,0.3];
	ghostSphere.render();
	popMatrix();
	
	//torso
	pushMatrix();
	mat4.translate(modelview, modelview, [9,0.25,0]);
	mat4.rotateX(modelview,modelview,(90)/180*Math.PI);
	ghostCylinder.render();
	popMatrix();
	
	var positions = [9, 0, 9.66, 0, 8.33, 0, 9.33, .6, 8.66, .6, 9.33, -.6, 8.66, -.6]
	
	//Bottome spikes
	for(var i = 0; i < 15; i+=2){
		pushMatrix();
		gl.uniform3f( u_material.emissiveColor, 0.3, 0, 0.0 );
		mat4.translate(modelview, modelview, [positions[i]-0.12,-.9,positions[i+1]]);
		mat4.rotateX(modelview,modelview,(90)/180*Math.PI);
		mat4.scale(modelview,modelview,[1.2,1.2,1.5]);
		mat4.rotateY(modelview,modelview,(-15)/180*Math.PI);
		currentColor = [0.6,0.5,1,0.3];
		ghostCone.render();
		popMatrix();
	}
	
	//The next to block of code add the beefy part.
	pushMatrix();
	gl.uniform3f( u_material.emissiveColor, 0.4, 0, 0.1);
	mat4.translate(modelview, modelview, [9,0.91,0]);
	mat4.rotateX(modelview,modelview,(90)/180*Math.PI);
	mat4.scale(modelview,modelview,[1.45,1.45,2.5]);
	torus.render();
	popMatrix();
	
	pushMatrix();
	mat4.translate(modelview, modelview, [9,-0.02,0]);
	mat4.rotateX(modelview,modelview,(90)/180*Math.PI);
	mat4.scale(modelview,modelview,[1.5,1.5, 3.5]);
	torus.render();
	popMatrix();
	
	//This section ontrols the eyebrows.
	pushMatrix();
	mat4.translate(modelview, modelview, [10,1.03,0.3]);
	mat4.scale(modelview,modelview,[.2, .4, .4]);
	mat4.rotateX(modelview,modelview,(60)/180*Math.PI);
	mat4.rotateZ(modelview, modelview, (90)/180*Math.PI);
	eyebrow.render();
	popMatrix();
	
	pushMatrix();
	mat4.translate(modelview, modelview, [10,1.03,-0.3]);
	mat4.scale(modelview,modelview,[.2, .4, .4]);
	mat4.rotateX(modelview,modelview,(120)/180*Math.PI);
	mat4.rotateZ(modelview, modelview, (90)/180*Math.PI);
	eyebrow.render();
	popMatrix();
	
	//Eyes
	var zEyePos = [0.33, -0.33];
	for(var i = 0; i <= 1; i++){
		pushMatrix();
		gl.uniform3f( u_material.emissiveColor, 0.6, 0.7, 0.8 );
		mat4.translate(modelview, modelview, [9.85, 0.9, zEyePos[i]]);
		mat4.scale(modelview,modelview,[0.3*1.5,0.3,0.3]);
		currentColor = [1,1,1,0.8];
		cube.render();
		popMatrix();
	}
	
	//Mustache THIS WAS AN ACCIDENT AND I LOVE IT
	var mPos = [10.05, .1, 10.05, -.1];
	for(var i = 0; i <= 3; i += 2){
		pushMatrix();
		mat4.translate(modelview, modelview, [(mPos[i]), 0.2, mPos[i+1]]);
		mat4.scale(modelview,modelview,[0.1,0.1,0.4]);
		mat4.rotateX(modelview, modelview, (45)/180*Math.PI)
		currentColor = [1,1,1,0.8];
		cube.render();
		popMatrix();
	}
	
	//mouth
	var mouthPos = [10,    .1,
					10,   -.1,
					9.97,  .3,
					9.97, -.3,
					9.9,   .5,
					9.9,  -.5];
	var mRota = [55,  0, 
				-55,  0,
				-55, -10,
				 55,  10,
				 55, -10,
				-55,  10];
	for(var i = 0; i <= 13; i += 2){
		pushMatrix();
		mat4.translate(modelview, modelview, [mouthPos[i] + 0.1, -.075, mouthPos[i+1]]);
		mat4.rotateX(modelview, modelview, (mRota[i])/180*Math.PI);
		mat4.rotateY(modelview, modelview, (mRota[i+1])/180*Math.PI);
		mat4.scale(modelview,modelview,[0.075,0.075,0.4]);
		currentColor = [1,1,1,0.8];
		cube.render();
		popMatrix();
	}
	
	//Creates the belt that the chain is connected too.
	pushMatrix();
	gl.uniform3f( u_material.emissiveColor, 0, 0, 0 );

	mat4.translate(modelview, modelview, [9, 0.5, 0]);
	mat4.scale(modelview,modelview,[1,4,1]);
	mat4.rotateX(modelview, modelview, (90)/180*Math.PI)
	currentColor = [0.396,0.263,0.129, 1];
	ring.render();
	popMatrix();
	gl.uniform3f( u_material.emissiveColor, 0, 0, 0 );
	mat4.translate(modelview, modelview, [0, 0, 0]);

	popMatrix();
}



/**
 * initialization function that will be called when the page has loaded
 * Took directly from diskplay.html. Added some additional lines for the 
 * additional CSS input options.
 */
function init() {
    try {
        var canvas = document.getElementById("webglcanvas");
        gl = canvas.getContext("webgl") || 
                         canvas.getContext("experimental-webgl");
        if ( ! gl ) {
            throw "Browser does not support WebGL";
        }
    }
    catch (e) {
        document.getElementById("message").innerHTML =
            "<p>Sorry, could not get a WebGL graphics context.</p>";
        return;
    }
    try {
        initGL();  // initialize the WebGL graphics context
    }
    catch (e) {
        document.getElementById("message").innerHTML =
            "<p>Sorry, could not initialize the WebGL graphics context:" + e + "</p>";
        return;
    }
    document.getElementById("animCheck").checked = false;
	document.getElementById("hLightCheck").checked = false;
	document.getElementById("sideLightCheck").checked = false;
	document.getElementById("amLightCheck").checked = false;
	document.getElementById("spLightCheck").checked = false;


	
    document.getElementById("reset").onclick = function() {
		rotator.setView(12,[6,1,4]);
		frameNumber = 0;
		xval = -18;      
		animating = false;
		document.getElementById("animCheck").checked = false;
	   	document.getElementById("hLightCheck").checked = false;
		document.getElementById("sideLightCheck").checked = false;
		document.getElementById("amLightCheck").checked = false;
		document.getElementById("spLightCheck").checked = false;
		document.getElementById("beefy").checked = false;
		document.getElementById("redSlider").value = 1;
		document.getElementById("greenSlider").value = 0;
		document.getElementById("blueSlider").value = 0;
		resetLightsAndBeefy();


		draw();
    }
    
    // As you create your scene use these or create from primitives
    torus = createModel(uvTorus(0.75,0.4,40,12));   // Create all the basic objects.
	eyebrow = createModel(uvTorus(0.75,0.1,40,12));   // Create all the basic objects.
    ghostSphere = createModel(uvSphere(1, 20, 20));
	sphere = createModel(uvSphere(3));
	var badSphere = createModel(uvSphere(2.8, 8, 6));
	sphereVertexCoords = getSphereCoords();
    cone = createModel(uvCone(),[0,0,.6]);
	ghostCone = createModel(uvCone(0.332, 0.8, 10));
    ghostCylinder = createModel(uvCylinder(1, 1.5, 0));
    disk = createModel(uvCylinder(20,0.5,64));
    cube = createModel(cube());
	ring = createModel(uvTorus(1.08,1,40,12));
	
 
 // This controls the zoom and initial placement
    rotator = new TrackballRotator(canvas,function() {
        if (!animating)
           draw();
    },12,[6,1,4]); 
    draw();
}

</script>
</head>
<body onload="init()">

<h2>Pac-Man Defense</h2>


<noscript><hr><h3>This page requires Javascript and a web browser that supports WebGL</h3><hr></noscript>

<p id="message" style="font-weight:bold">Drag your mouse on the model to rotate it. To reset the light colors uncheck and check the light.<br></p>

<p>
   <label><input type="checkbox" id="animCheck" onchange="setAnimating(this.checked)">Animate</label>
   <label><input type="checkbox" id="beefy" onchange="beefy(this.checked)">Beefy Ghost</label>
   <br><label><input type="checkbox" id="hLightCheck" onchange="hLightUpdate(this.checked)">Head on Light</label>
   <label><input type="checkbox" id="sideLightCheck" onchange="sideLightUpdate(this.checked)">Side Light</label>
   <label><input type="checkbox" id="amLightCheck" onchange="amLightUpdate(this.checked)">Ambient(ish) Light</label>
   <label><input type="checkbox" id="spLightCheck" onchange="spLightUpdate(this.checked)">Spotlights</label>
    <button id="reset" style="margin-left:40px">Reset</button></br>

   <label>Red  <input type="range" id="redSlider" onchange="updateRed(this.value)" min="0" max="1" value="1" step="0.01" /></label>
   <label>Green  <input type="range" id="greenSlider" onchange="updateGreen(this.value)" min="0" max="1" value="0" step="0.01" /></label>
   <label>Blue  <input type="range" id="blueSlider" onchange="updateBlue(this.value)" min="0" max="1" value="0" step="0.01" /></label>
   
</p>


<div>

    <canvas width=640 height=640 id="webglcanvas" style="background-color:blue"></canvas>

</div>
</body>
</html>